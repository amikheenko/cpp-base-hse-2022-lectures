
# Лекция 16 (11.03.2022)

#### Потоки ввода и вывода

Потоки ввода и вывода - основная абстракция для сериализации объектов в некоторое хранилище.

Базовый пример:

```cpp
std::cout << "Hello" << std::endl;
```

Стандартные библиотеки помогают нам работать с тремя типами потоков: 
* **std::cout (вывод)**
* **std::cin (ввод)**
* **std::cerr (ошибки)**

#### Перенаправление вывода в файл из терминала

```cpp
> log.txt  // запись в файл (стирается содержимое)
>> log.txt  // запись в файл (дополнение содержимого)
2> log.txt // запись ошибки в файл (стирается файл)
2>> log.txt // запись ошибки в файл (дополнение содержимого)
>log.txt 2>&1 //  запись в log.txt и перенаправление вывода ошибок в обычный  вывод (смешали потоки)
```
Дескрипторы:
1 - std::cout (опускается обычно);
2 - std::cerr;
```cpp
2>&1 | grep err // grep - поиск подстроки "err" в "Hello err". Работает и с regex
```
* Hello **err**

Через `echo 10 | /lecture` можно передать в `std::cin` число 10 прямо из терминала

#### Иерархия классов

[![](https://upload.cppreference.com/mwiki/images/0/06/std-io-complete-inheritance.svg)](http://https://upload.cppreference.com/mwiki/images/0/06/std-io-complete-inheritance.svg)

#### Чтение файлов

```cpp
include <fstream>

int main() {
	std::ifstream in("somepath.txt", std::ios::in | std::ios::binary);
	// второй аргумент является режимом открытия файла.
}
```
**Некоторые режимы:**
* `binary` - открытие в бинарном формате
* `out` - открыть для записи
* `in` - открыть для чтения
* `app` - в конец файла

**Работает чтение в двух режимах:**
* Текстовый - предполагается, что в файле текст
* Бинарный - любые значения символа


`>>` - оператор форматированного ввода
`<<` - оператор форматированного вывода

**Представляет типы данных в текстовом представлении**
```cpp
std::cout << 1.312 << std::endl;
	<< 1.312
std::cout << 10 << std::endl;
	<< 10
```
```
// Lorem 10 Good Luck Have Fun
std::ifstream in("text.txt", std::ios::in); 
std::string str;
int i;
in >> str;
in >> i;
std::cout << str << std::endl; // до первого пробела прочитал слово
	<< Lorem
std::cout << i << std::endl; // вывел первое число из текста
	<< 10
```
**Состояния работы `in`: (1 или 0)**
* in.good() (1 - нет ошибок, иначе 0)
* in.fail() (1 - ошибка, иначе 0)
* in.bad() (в зависимости от установленных флагов ошибок)
* in.eof() (1 - если достигнут конец файла, 0 - иначе, -1 - ошибка )

Выставить исключения: `in.exceptions(in.failbit)`

#### Хранение байтов
* Машины с порядком хранения от старшего к младшему (прямой порядок) хранят старший байт первым. Если посмотреть на набор байтов, то первый байт (младший адрес) считается старшим. Big-endian
* Машины с порядком хранения от младшего к старшему (обратный порядок) хранят младший байт первым. Если посмотреть на набор байт, то первый байт будет наименьшим. Little-endian
